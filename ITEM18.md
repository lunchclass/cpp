# 소유권 독점 자원의 관리에는 std::unique_ptr를 사용하라

일반 포인터의 단점을 먼저 나열해보면 아래와 같다.

 1. 선언만 봐서는 배열을 가리키는지 객체 하나를 가리키는지 구분할 수 없다.
    그렇기 때문에 delete를 사용해야 하는지 delete[]를 사용해야 하는지 알 수 없다.
 2. 선언만 봐서는 포인터가 객체를 가리키고 있는지 아닌지 알 수 없다.
 3. 선언만 봐서는 메모리를 해제 할 때 delete를 사용하면 되는지 특정 해제 메커니즘을 사용해야 하는지 알 수 없다.
 4. 모든 경로에서 메모리 해제가 정확히 한번 일어남을 보장하기 어렵다.

위 단점을 예를 들어 확인해보자.

```c++
char* foo;
char* bar;
 
foo = factory(...);
bar = factory(...);
```
위  foo와 bar의 해제하기 위해서는 factory 함수의 정의를 확인해서 어떤 포인터를 리턴하는지 확인해야하는 불편함이 있다.

```c++
char* foo;

foo = new char;

if(...) {
  delete foo;
  return;
}

if(...) {
  delete foo;
  return;
}

//using foo
```
위와 같이 함수에서 foo를 할당한 후 발생하는 모든 예외에 대해서 해제함수를 고려해야한다.

std::unique_ptr의 장점을 확인해보자.

1. 선언에 어떤 해제 함수를 사용해야 하는지 명확히 한다.
2. 선언에 배열의 포인터인지 객체 하나의 포인터인지 명확히 한다.
3. 소멸자를 이용하여 메모리 해제를 하기 때문에 사용자는 scope 만 신경쓰면 된다.
4. 객체의 포인터가 공유되는 것을 근본적으로 막는다.
